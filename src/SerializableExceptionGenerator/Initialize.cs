using System.Text;
using Microsoft.CodeAnalysis;

namespace SerializableExceptionGenerator;

[Generator(LanguageNames.CSharp)]
public class SerializableExceptionGenerator : IIncrementalGenerator
{
    private const string GeneratorAttributeShortHandName = "SerializableException";
    private const string GeneratorAttributeName = $"{GeneratorAttributeShortHandName}Attribute";
    private const string GeneratorNamespace = "SerializableExceptionGenerator";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var source = context.SyntaxProvider.ForAttributeWithMetadataName(
            $"{GeneratorNamespace}.{GeneratorAttributeName}",
            static (_, _) => true,
            static (context, _) => context
        );

        context.RegisterSourceOutput(source, Emit);

        context.RegisterPostInitializationOutput(static postInitializationContext =>
        {
            // 引数用のEnumってどこに実装するのがいいんだろう
            // 生成するコードに書くと、二重管理になってめんどくさい気がするんだよな
            postInitializationContext.AddSource(
                $"{GeneratorAttributeName}.cs",
                $$"""
// <auto-generated>
// THIS FILE IS GENERATED BY SerializableExceptionGenerator. DO NOT EDIT IT.
// </auto-generated>

namespace {{GeneratorNamespace}} {

	[global::System.AttributeUsage(global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
	internal sealed class {{GeneratorAttributeName}} : global::System.Attribute {
		public GenerateTarget Target { get; set; }

        public {{GeneratorAttributeName}}(GenerateTarget target = GenerateTarget.All) {
			this.Target = target;
        }
	}


    [global::System.Flags]
    internal enum GenerateTarget
    {
        None = 0,
        DefaultConstructor = 1,
        StringMessageConstructor = 1 << 1,
        StringMessageExceptionConstructor = 1 << 2,
        SerializationInfoStreamingContextConstructor = 1 << 3,
        All =
            DefaultConstructor
            | StringMessageConstructor
            | StringMessageExceptionConstructor
            | SerializationInfoStreamingContextConstructor
    }
}
"""
            );
        });
    }

    private static string? GetNamespace(INamedTypeSymbol symbol) =>
        symbol.ContainingNamespace.IsGlobalNamespace
            ? null
            : symbol.ContainingNamespace.ToDisplayString();

    private static void Emit(
        SourceProductionContext context,
        GeneratorAttributeSyntaxContext source
    )
    {
        var symbol = (INamedTypeSymbol)source.TargetSymbol;

        var sanitizedFullName = symbol
            .ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)
            .Replace("global::", "")
            .Replace("<", "_")
            .Replace(">", "_");

        var targetAttributeSymbol =
            source.SemanticModel.Compilation.GetTypeByMetadataName(
                $"{GeneratorNamespace}.{GeneratorAttributeName}"
            ) ?? throw new NullReferenceException();

        // SerializableExceptionAttribute だけをひっかけて、その引数を取得したい
        // ForAttributeWithMetadataName の transform でやればいい気がしなくもない
        var targetAttribute =
            symbol
                .GetAttributes()
                .FirstOrDefault(
                    a =>
                        SymbolEqualityComparer.Default.Equals(
                            a.AttributeClass,
                            targetAttributeSymbol
                        )
                ) ?? throw new NullReferenceException();

        var target = (GenerateTarget)targetAttribute.ConstructorArguments[0].Value!;

        var code = GenerateCode(symbol, target);
        context.AddSource($"{sanitizedFullName}.exception.g.cs", code);
    }

    private static string GenerateCode(INamedTypeSymbol symbol, GenerateTarget target)
    {
        var @namespace = GetNamespace(symbol);
        var sb = new StringBuilder();
        sb.AppendLine(
            """
// <auto-generated>
// THIS FILE IS GENERATED BY SerializableExceptionGenerator. DO NOT EDIT IT.
// </auto-generated>

"""
        );

        if (@namespace is not null)
        {
            sb.AppendLine($$"""
namespace {{@namespace}};

""");
        }

        sb.AppendLine(
            $$"""
[global::System.Serializable]
public partial class {{symbol.Name}} : global::System.Exception
{
"""
        );

        if (target.HasFlag(GenerateTarget.DefaultConstructor))
        {
            sb.AppendLine($$"""
	public {{symbol.Name}}() { }
""");
        }

        if (target.HasFlag(GenerateTarget.StringMessageConstructor))
        {
            sb.AppendLine($$"""
	public {{symbol.Name}}(string message) : base(message) { }
""");
        }

        if (target.HasFlag(GenerateTarget.StringMessageExceptionConstructor))
        {
            sb.AppendLine(
                $$"""
	public {{symbol.Name}}(string message, global::System.Exception inner) : base(message, inner) { }
"""
            );
        }

        if (target.HasFlag(GenerateTarget.SerializationInfoStreamingContextConstructor))
        {
            sb.AppendLine(
                $$"""
	protected {{symbol.Name}}(
		global::System.Runtime.Serialization.SerializationInfo info,
		global::System.Runtime.Serialization.StreamingContext context
	) : base(info, context) { }
"""
            );
        }

        sb.AppendLine("}");

        return sb.ToString();
    }
}
